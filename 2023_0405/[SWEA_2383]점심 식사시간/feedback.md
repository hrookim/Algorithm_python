### 문제풀이 결과

1. 성공 (하지만, 직접 코드를 짤 수 없어 블로그 코드를 공부한 후 통과했다)



### 실패 원인

* 설계에서 접근하지 못했다.
* N의 범위가 작고, 사람 수도 많지 않고, 계단에서 이동하는 데에 걸리는 시간도 작으므로 완전탐색을 해도 괜찮다.
* 그래서 계단1/계단2로 들어갈 수 있는 사람들을 itertools의 combinations를 써서 나눠주었고,
  전체 이동을 하는 `go_for_lunch(subgroup, stair)`함수를 만들었다.
* `go_for_lunch(subgroup, stair)` 함수는 하나의 서브그룹과 그 그룹이 이동할 계단을 받아서, 걸리는 최대 이동시간을 산출하는 함수이다. 이때 이동은 `1) 계단까지 이동하는 시간` + `2) 계단에서 내려가는 시간`을 포함해야 하는데, 각각에서 이동하고 있는 사람들을 `deque()`로 만들어주었다. 
  * 계단에 도달하는 시간이 현재 시간보다 작다는 것은, 현재 시간에 이미 계단에는 도달했음을 말해준다. 이때 `<=`가 아닌 `<`를 사용한 것은 도착 후 1분 후부터 이동을 할 수 있기 때문이다.
  * 그렇게 도달했다는 것이 판명되었으면, 계단에서 이동할 수 있는지를 봐야한다. 계단에서 이동하고 있는 사람들`deque()`의 길이가 3보다 작은지를 체크해서, 작다면 계단까지 이동하고 있는 사람들에서 `.popleft()`를 해주고 계단에서 내려가고 있는 `deque()`에 포함시켜 준다. 이때 원래 가지고 있는 시간으로 포함시키는 것이 아니라, 계단을 다 내려간 후 시간으로 포함시켜야 한다. 즉 현재시간 + 계단 단계 `time + stair level`을 넣어주는 것이다.
  * 이 과정을 반복하다보면 맨 마지막 요소에 도달하게 되는데, 마지막 요소의 경우 계단에서 내려가는 사람들이 비워져있다면, 바로 계단에 들어가서 이동시키면 끝이므로, `time += stair level`을 하고 while문을 `break`하면 된다. 




### 오늘의 교훈

**모의문제.. 기출문제... 다 열심히 풀어봐야 한다**
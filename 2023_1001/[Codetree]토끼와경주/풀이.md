## 풀이

- 변수

  - **`N`, `M`, `P`**: 격자 행크기, 열크기, 토끼마리 수

  - **`rabbit_dict`**: 토끼의 고유번호를 key로 하여, 거리와 점수 정보를 가지고 있는 딕셔너리

    ```python
    rabbit_dict = {
    	pid : {
    		"score": 0,
    		"distance": 3
    	},
    }
    ```

  - **`rabbit_q`**: 문제에서 주어진 우선순위를 판별해 가지고 있는 **우선순위큐**

    ```python
    # 우선순위큐에 튜플을 넣으면, 원소 순서대로 오름차순 정렬을 해준다.
    rabbit_q.put((total_jump, r+c, r, c, pid))
    ```

  - **`loss_score`**: 반복 점수 계산을 피하기 위해 일부러 누락해둔 점수

- 함수

  - **`prepare(info)`**: 경주 시작 준비 함수

    - `rabbit_dict`와 `rabbit_q` 초기화를 한다.

  - **`race(K, S)`** : 경주 진행 함수

    - K번의 턴을 돌면서
      - 움직일 토끼 뽑기
      - 이동할 위치 선택하기 (4방향 중 우선순위 높은 곳) → 토끼 움직이기
      - 다른 토끼들한테 점수 주기 (=움직인 토끼한테만 점수 깍기)
    - K번의 턴 끝나면, 움직인 토끼들 중에서 가장 우선순위 높은 애한테 S점 주기

    ------

    - 변수
      - `race_point_q`: 이동할 위치 4개를 담아 가장 우선순위 높은 곳을 찾기 위한 우선순위 큐
      - `moved_rabbit_dict`: 움직인 토끼의 정보를 담는 딕셔너리
      - `moved_rabbit_q`: 움직인 토끼 중 우선순위 높은 토끼 찾기 위한 우선순위 큐

  - **`change_distance(pid, L)`**: 특정 토끼의 이동거리를 L배하는 함수

  - **`find_the_best()`**: 전체 토끼의 점수 중 최대값 찾기

    - 이때, `loss_score`로 빠져있던 점수를 추가해줘야 원래값이 나온다!



## 어려웠던 점

- 소요시간: 2시간 반 정도 (다행히도 1트만에 정답!! 감격의 눈물… 😭)
- 시간개선을 위해 신경 쓴 부분
  - 우선순위를 판별하는 것이 많았다!!! 우선순위큐를 사용하면 직접 순회해서 비교하지 않아도 됨
  - 격자에서 범위를 벗어나면 반대로 움직인다! (이 로직.. 넘나리 어려웠다)
    - 이동거리가 L배 늘어난다고 했을 때, 매번 모든 칸 움직여줘야 할까? → 아니다!!!
  - P-1마리 토끼에게 점수를 제공한다
    - 1마리만 점수를 뺀다. 그리고 그 loss를 기록해서 나중에 회복시켜준다.



## 복잡도

* 소요시간, 메모리: `3933ms` `76MB`

- O(100) * 3*O(logn) + O(2000)
  - K최대 * 우선순위큐 3개 + 마지막 점수 최고인 아이 찾기 (맞나?🤔)